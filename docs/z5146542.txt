Seung Hoon Park's Diary
Week 1
z5146542

Week 1
We formed a group and created a Jira account under the project name 'usepackage'. Altogether we discussed what kind of custom project to do, and I proposed a online music score editor, which is hardly used in contrast to online text editors. Ultimately, we decided we would be working on a online sound editor (also rarely used), and we gathered some information of some sample online editors, primarily their strengths and their weaknesses. We also found an audio API that we could potentially use for the project. We have created a draft project description and had it sent to our client for revision.

Week 2
After getting feedback from the client, we modified the project description so that there are no ambiguities. I wrote a rough response to the questions the client had, and the scrum master (Madhav), who originally sent the first email to the client, tweaked the response and sent it back to the client for approval. On Friday, we had another meeting and we started on sorting out the user stories. I also had the chance to get a basic jist on how to use the backlog for Jira. Although we have not posted anything significant on the backlog of Jira yet, my teammates and I formed user stories on overleaf, where we designed a nontrivial amount of user stories and their corresponding acceptance criteria. This is almost done; once this is finished, we plan on moving all the user stories to the backlog. In the meantime, I am going familiarise myself with overleaf and typescript. 

Week 3
Today our team have met up in Blackboard Collaborate and discussed about what further actions we need to do in terms of writing our proposal. At 2pm we have met online and finalised most of the user stories by adding user story points. We have also tested out the basic framework in which this project will be based on. Throughout the remainder of the week, Rajiv and Ethan set up the basic framekwork for the repository. All of us spent time on writing the proposal for our project. At Saturday, Rajiv and I spent the entire day creating draft version of the Interface-Flow diagram. On Sunday, we split the diagram into separate interface diagram and flow diagram. This was necessary since the combined diagram did not fit into a single page. The remaining Sunday was spent finalising the Proposal.

Week 4
During Monday, we spent out time understanding how MongoDB works. Throughout the rest of the week, I worked on setting up two things: the stop button logic and the gain bar (or the volume bar). The basic idea is that once a sound file is uploaded, the stop button would stop the sound file if it was playing on the browser. The gain bar dynamically changes the volume of the sound file. I also added a function that renders the visualisers for the uploaded audio files. Finally, I added the play/pause and stop buttons with the logic linked to the handlers. The buttons work as intended. I also fixed bugs that prevented the user from uploading files and playing the files online without error. I created a new repository called test and attempted to import ffmpeg-js. This client-side module should allow converting any audio file to wav, mp3 or ogg from the client side, but more experimentation needs to be done.

Week 5
On Sunday, I spent my time trying to get ffmpeg-js working. The idea is that ffmpeg-js depends on js's webworker and works just like the commandline equivalent. I spent my time setting up the logic for parsing the arguments but found out that ffmpeg-js have some missing encoder codecs responsible for converting audio files to the format we desire. I also imported the soundtouch library that will hopefully aid with the seeking and playback functionalities. On Monday, I refactored the code into three modules. AudioStack deals with the overall online playback logic of uploaded files. AudioTrack deals with the logic for setting up the gain, pitch, etc. for each uploaded channel. I also worked on displaying the objects responsible for selecting time for an uploaded audio file. I also added the download options responsible for choosing the format options (WAV, MP3 and OGG). I also modified record so once the user clicks download, record() would actually convert the file to the appropriate format and start downloading the file on the client side. 

Week 6
I worked on further improving the uploadHandler and time visualiser. I also finished polishing rendering each audio track. I also worked on displaying and rendering the download handler. Now, once the user clicks on the download button, a modal will appear, and the modal will have radio buttons displaying MP3, OGG, WAV, and MONO/STEREO. The user may choose an encoding option and channel option, then after some time, download will proceed. To make this work, I also defined the record function that converts the project to the desired audio format.

Week 7
I constructed a PromiseQueue. PromiseQueue allows us to store promises in a queue that takes form of an array. Once the queue is filled, the user can, in sequence, resolve all the promises synchronously. This is really helpful with async-based forEach loops, where promises cannot be directly used. This week I designed the MongoDB schema with Rajiv and Rui. We constructed the User schema with the appropriate routing. It does not fully work at the moment, but we plan on getting it to work soon. 

Week 8
Along with Rajiv and Rui we designed the Project Schema for MongoDB and the back end. I also added the appropriate routing for this schema. Basic functionality works at the moment, but we need to add more routing methods for projects. Routes now send messages instead of sending json objects for easier debugging. With the appropriate routing we designed the login and register page for the front end. Now, not only does the login and register pages display correctly, they also work! Most importantly, to ensure we get the features working as we want, we fully broke apart the soundtouch library and customised such that they work with worklets in a way we intended. Finally, I also made it possible so that multiple audio files can be uploaded and downloaded for a single project. 

Week 9
Added further routing for the projects. This allows for checking whether enough space exists for uploading additional audio files to a given project. We also modified the way audio files are stored in the database. We now purge all audio files in the database before saving them to the database. This allows us to avoid any ordering conflicts between audio files whenever they are retrieved from the database. I also worked with Rajiv so that edit histories for each audio file in a given project are stored in the database (they, however, don't load successfully, so we need to work on that very soon). I also got tagging projects to work. Projects in the profile page can now be filtered by tags. Furthermore, I make the deletion of projects, search of projects, and sorting of projects (based on name and date ascending/descending order) work, completing user story 22. I also got project metadata to display and be modified by the owner or collaborator. I also got the sharelink to work. Now I am working on concurrent lock to work (i.e. only one user should be editing a project at a given time). UPDATE: concurrency lock works now. The solution is to poll every 30 seconds to the back end. Every time a poll is performed, the token responsible for validating a session is updated both in the database and in the user session. 

Week 10
Got the rest of the backend stuff to work. I also attempted to improve the UI by fidelling with the CSS sides of things. Finally, our team worked on fixing any remaining bugs our program had. We also spent some time writing the report and preparing for the presentation together. 
